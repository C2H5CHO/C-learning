# 一、问题描述  
> 在一个 $n \times m$  的矩阵中，有一个数字出现了超过一半的次数，请设计一个高效算法找到这个数字。
## 1.1 输入格式
> 输入第一行包含两个整数 $n$ 和 $m$，表示矩阵的大小 $(1 \leq n, m \leq 10^3)$。
> 接下来 $n$ 行，每行包含 $m$ 个正整数，表示矩阵中的元素。  
## 1.2 输出格式
> 输出一个整数，表示矩阵中出现次数超过一半的数字。
## 1.3 样例输入
- 输入：

```
3 3
1 2 3
2 2 2
1 2 2
```
- 输出：

```
2
```
**原题链接**：[找到最多的数](https://www.lanqiao.cn/problems/3227/learning/?page=1&first_category_id=1&problem_id=3227)
# 二、解题思路
## 2.1 当“记数员”：统计每个数字出现的次数：
> 想象我们有一个超级大的矩阵，里面全是数字。现在要找一个“显眼包”数字——它出现的次数超过整个矩阵元素数量的一半。那怎么找呢？

- 首先，我们当“记数员”。准备一个小本本（代码里的 `map`，相当于数字的计数器），然后把矩阵里的数字一个一个拿出来看
- 每看到一个数字，就去小本本里找这个数字对应的计数。比如第一次看到数字2，就给它记1次；第二次再看到2，就把计数改成2，以此类推。这样把矩阵里所有数字都过一遍，每个数字出现了多少次，小本本上就都记清楚了
## 2.2 当“检查员”：找出符合条件的数字：
> 现在小本本上记好了每个数字的出现次数。接下来当“检查员”，逐个检查小本本里的数字。

- 整个矩阵的元素总数是 `n×m` 个，超过一半的标准就是：这个数字的出现次数 `×2` 要大于 `n×m`。比如矩阵有6个元素，超过一半就是出现次数至少4次（4×2=8 > 6）
- 只要发现某个数字的计数满足这个条件，它就是我们要找的“显眼包”数字，直接把它揪出来就大功告成！  

> 整个过程就像在一堆糖果里，找哪种糖果数量超过一半：先数每种糖果有多少颗，再检查哪种糖果的数量符合要求，简单直接又高效。
# 三、代码详解

```cpp
#include <bits/stdc++.h>
using namespace std;

map<int, int> mp;

int main()
{
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int n, m;
  cin >> n >> m;
  for(int i = 1; i <= n*m; i++){
    int x;
    cin >> x;
    mp[x] ++;
  }

  for(const auto &[x, y]:mp){
    if(2*y > n*m){
      cout << x << '\n';
    }
  }

  return 0;
}
```
1. **输入与初始化**：
	- `ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);`：优化输入输出速度
	- 读取矩阵大小 $n$ 和 $m$
2. **统计频率**：
	- 通过循环读取 $n \times m$ 个元素，用 `mp[x]++` 统计每个数字 $x$ 的出现次数
3. **筛选结果**：
	- 遍历 `map`，对每个数字 $x$ 的计数 $y$，判断是否满足 $2 \times y > n \times m$。若满足，输出 $x$ 并结束程序
----
`微语录：把自己活成一束光，自信坦荡，光芒万丈。`
